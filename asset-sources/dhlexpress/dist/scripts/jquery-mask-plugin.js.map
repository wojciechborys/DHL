{"version":3,"sources":["../bower_components/jquery-mask-plugin/dist/jquery.mask.js"],"names":["factory","jQuery","Zepto","define","amd","exports","Meteor","module","require","$","Mask","el","mask","options","p","invalid","getCaret","sel","pos","ctrl","get","dSel","document","selection","cSelStart","selectionStart","navigator","appVersion","indexOf","createRange","moveStart","val","length","text","e","setCaret","is","range","setSelectionRange","createTextRange","collapse","moveEnd","select","events","on","data","keyCode","which","maskDigitPosMapOld","maskDigitPosMap","jMaskGlobals","useInput","behaviour","setTimeout","keydown","keyup","oldValue","trigger","selectOnFocus","target","clearIfNotMatch","regexMask","test","getRegexMask","translation","pattern","optional","recursive","oRecursive","r","maskChunks","i","jMask","charAt","toString","replace","push","digit","join","RegExp","destroyEvents","off","v","isInput","method","arguments","calculateCaretPosition","oldVal","newVal","getMasked","caretPosNew","caretPosOld","newValL","oldValL","maskDigitsBeforeCaret","maskDigitsAfterCaret","maskDigitsBeforeCaretAll","maskDigitsBeforeCaretAllOld","caretPos","window","event","inArray","byPassKeys","keyStrokeCompensation","callbacks","skipMaskChars","lastMaskChar","check","buf","value","undefined","m","maskLen","valLen","offset","addMethod","resetPos","maskDigitCount","maskDigitPosArr","reverse","lastUntranslatedMaskChar","maskDigit","valDigit","match","fallback","lastMaskCharDigit","mapMaskdigitPositions","maskDiff","changed","defaultArgs","callback","name","criteria","args","apply","this","remove","caret","placeholder","removeAttr","getCleanVal","getMaskedVal","init","onlyMask","extend","attr","maxlength","maskWatchers","HTMLAttributes","input","prefix","notSameMaskObject","field","maskObject","stringify","JSON","fn","selector","globals","interval","watchInterval","watchInputs","maskFunction","each","clearInterval","setInterval","find","masked","unmask","dataMask","removeData","cleanVal","applyDataMask","maskElements","filter","dataMaskAttr","userAgent","eventName","isSupported","createElement","setAttribute","watchDataMask","0","9","#","A","S"],"mappings":"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","file":"jquery-mask-plugin.js","sourcesContent":["/**\n * jquery.mask.js\n * @version: v1.14.16\n * @author: Igor Escobar\n *\n * Created by Igor Escobar on 2012-03-10. Please report any bug at github.com/igorescobar/jQuery-Mask-Plugin\n *\n * Copyright (c) 2012 Igor Escobar http://igorescobar.com\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* jshint laxbreak: true */\n/* jshint maxcomplexity:17 */\n/* global define */\n\n// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.\n// https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js\n(function (factory, jQuery, Zepto) {\n\n    if (typeof define === 'function' && define.amd) {\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object' && typeof Meteor === 'undefined') {\n        module.exports = factory(require('jquery'));\n    } else {\n        factory(jQuery || Zepto);\n    }\n\n}(function ($) {\n    'use strict';\n\n    var Mask = function (el, mask, options) {\n\n        var p = {\n            invalid: [],\n            getCaret: function () {\n                try {\n                    var sel,\n                        pos = 0,\n                        ctrl = el.get(0),\n                        dSel = document.selection,\n                        cSelStart = ctrl.selectionStart;\n\n                    // IE Support\n                    if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {\n                        sel = dSel.createRange();\n                        sel.moveStart('character', -p.val().length);\n                        pos = sel.text.length;\n                    }\n                    // Firefox support\n                    else if (cSelStart || cSelStart === '0') {\n                        pos = cSelStart;\n                    }\n\n                    return pos;\n                } catch (e) {}\n            },\n            setCaret: function(pos) {\n                try {\n                    if (el.is(':focus')) {\n                        var range, ctrl = el.get(0);\n\n                        // Firefox, WebKit, etc..\n                        if (ctrl.setSelectionRange) {\n                            ctrl.setSelectionRange(pos, pos);\n                        } else { // IE\n                            range = ctrl.createTextRange();\n                            range.collapse(true);\n                            range.moveEnd('character', pos);\n                            range.moveStart('character', pos);\n                            range.select();\n                        }\n                    }\n                } catch (e) {}\n            },\n            events: function() {\n                el\n                .on('keydown.mask', function(e) {\n                    el.data('mask-keycode', e.keyCode || e.which);\n                    el.data('mask-previus-value', el.val());\n                    el.data('mask-previus-caret-pos', p.getCaret());\n                    p.maskDigitPosMapOld = p.maskDigitPosMap;\n                })\n                .on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour)\n                .on('paste.mask drop.mask', function() {\n                    setTimeout(function() {\n                        el.keydown().keyup();\n                    }, 100);\n                })\n                .on('change.mask', function(){\n                    el.data('changed', true);\n                })\n                .on('blur.mask', function(){\n                    if (oldValue !== p.val() && !el.data('changed')) {\n                        el.trigger('change');\n                    }\n                    el.data('changed', false);\n                })\n                // it's very important that this callback remains in this position\n                // otherwhise oldValue it's going to work buggy\n                .on('blur.mask', function() {\n                    oldValue = p.val();\n                })\n                // select all text on focus\n                .on('focus.mask', function (e) {\n                    if (options.selectOnFocus === true) {\n                        $(e.target).select();\n                    }\n                })\n                // clear the value if it not complete the mask\n                .on('focusout.mask', function() {\n                    if (options.clearIfNotMatch && !regexMask.test(p.val())) {\n                       p.val('');\n                   }\n                });\n            },\n            getRegexMask: function() {\n                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;\n\n                for (var i = 0; i < mask.length; i++) {\n                    translation = jMask.translation[mask.charAt(i)];\n\n                    if (translation) {\n\n                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');\n                        optional = translation.optional;\n                        recursive = translation.recursive;\n\n                        if (recursive) {\n                            maskChunks.push(mask.charAt(i));\n                            oRecursive = {digit: mask.charAt(i), pattern: pattern};\n                        } else {\n                            maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));\n                        }\n\n                    } else {\n                        maskChunks.push(mask.charAt(i).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'));\n                    }\n                }\n\n                r = maskChunks.join('');\n\n                if (oRecursive) {\n                    r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')\n                         .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);\n                }\n\n                return new RegExp(r);\n            },\n            destroyEvents: function() {\n                el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));\n            },\n            val: function(v) {\n                var isInput = el.is('input'),\n                    method = isInput ? 'val' : 'text',\n                    r;\n\n                if (arguments.length > 0) {\n                    if (el[method]() !== v) {\n                        el[method](v);\n                    }\n                    r = el;\n                } else {\n                    r = el[method]();\n                }\n\n                return r;\n            },\n            calculateCaretPosition: function(oldVal) {\n                var newVal = p.getMasked(),\n                    caretPosNew = p.getCaret();\n                if (oldVal !== newVal) {\n                    var caretPosOld = el.data('mask-previus-caret-pos') || 0,\n                        newValL = newVal.length,\n                        oldValL = oldVal.length,\n                        maskDigitsBeforeCaret = 0,\n                        maskDigitsAfterCaret = 0,\n                        maskDigitsBeforeCaretAll = 0,\n                        maskDigitsBeforeCaretAllOld = 0,\n                        i = 0;\n\n                    for (i = caretPosNew; i < newValL; i++) {\n                        if (!p.maskDigitPosMap[i]) {\n                            break;\n                        }\n                        maskDigitsAfterCaret++;\n                    }\n\n                    for (i = caretPosNew - 1; i >= 0; i--) {\n                        if (!p.maskDigitPosMap[i]) {\n                            break;\n                        }\n                        maskDigitsBeforeCaret++;\n                    }\n\n                    for (i = caretPosNew - 1; i >= 0; i--) {\n                        if (p.maskDigitPosMap[i]) {\n                            maskDigitsBeforeCaretAll++;\n                        }\n                    }\n\n                    for (i = caretPosOld - 1; i >= 0; i--) {\n                        if (p.maskDigitPosMapOld[i]) {\n                            maskDigitsBeforeCaretAllOld++;\n                        }\n                    }\n\n                    // if the cursor is at the end keep it there\n                    if (caretPosNew > oldValL) {\n                      caretPosNew = newValL * 10;\n                    } else if (caretPosOld >= caretPosNew && caretPosOld !== oldValL) {\n                        if (!p.maskDigitPosMapOld[caretPosNew])  {\n                          var caretPos = caretPosNew;\n                          caretPosNew -= maskDigitsBeforeCaretAllOld - maskDigitsBeforeCaretAll;\n                          caretPosNew -= maskDigitsBeforeCaret;\n                          if (p.maskDigitPosMap[caretPosNew])  {\n                            caretPosNew = caretPos;\n                          }\n                        }\n                    }\n                    else if (caretPosNew > caretPosOld) {\n                        caretPosNew += maskDigitsBeforeCaretAll - maskDigitsBeforeCaretAllOld;\n                        caretPosNew += maskDigitsAfterCaret;\n                    }\n                }\n                return caretPosNew;\n            },\n            behaviour: function(e) {\n                e = e || window.event;\n                p.invalid = [];\n\n                var keyCode = el.data('mask-keycode');\n\n                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {\n                    var newVal = p.getMasked(),\n                        caretPos = p.getCaret(),\n                        oldVal = el.data('mask-previus-value') || '';\n\n                    // this is a compensation to devices/browsers that don't compensate\n                    // caret positioning the right way\n                    setTimeout(function() {\n                      p.setCaret(p.calculateCaretPosition(oldVal));\n                    }, $.jMaskGlobals.keyStrokeCompensation);\n\n                    p.val(newVal);\n                    p.setCaret(caretPos);\n                    return p.callbacks(e);\n                }\n            },\n            getMasked: function(skipMaskChars, val) {\n                var buf = [],\n                    value = val === undefined ? p.val() : val + '',\n                    m = 0, maskLen = mask.length,\n                    v = 0, valLen = value.length,\n                    offset = 1, addMethod = 'push',\n                    resetPos = -1,\n                    maskDigitCount = 0,\n                    maskDigitPosArr = [],\n                    lastMaskChar,\n                    check;\n\n                if (options.reverse) {\n                    addMethod = 'unshift';\n                    offset = -1;\n                    lastMaskChar = 0;\n                    m = maskLen - 1;\n                    v = valLen - 1;\n                    check = function () {\n                        return m > -1 && v > -1;\n                    };\n                } else {\n                    lastMaskChar = maskLen - 1;\n                    check = function () {\n                        return m < maskLen && v < valLen;\n                    };\n                }\n\n                var lastUntranslatedMaskChar;\n                while (check()) {\n                    var maskDigit = mask.charAt(m),\n                        valDigit = value.charAt(v),\n                        translation = jMask.translation[maskDigit];\n\n                    if (translation) {\n                        if (valDigit.match(translation.pattern)) {\n                            buf[addMethod](valDigit);\n                             if (translation.recursive) {\n                                if (resetPos === -1) {\n                                    resetPos = m;\n                                } else if (m === lastMaskChar && m !== resetPos) {\n                                    m = resetPos - offset;\n                                }\n\n                                if (lastMaskChar === resetPos) {\n                                    m -= offset;\n                                }\n                            }\n                            m += offset;\n                        } else if (valDigit === lastUntranslatedMaskChar) {\n                            // matched the last untranslated (raw) mask character that we encountered\n                            // likely an insert offset the mask character from the last entry; fall\n                            // through and only increment v\n                            maskDigitCount--;\n                            lastUntranslatedMaskChar = undefined;\n                        } else if (translation.optional) {\n                            m += offset;\n                            v -= offset;\n                        } else if (translation.fallback) {\n                            buf[addMethod](translation.fallback);\n                            m += offset;\n                            v -= offset;\n                        } else {\n                          p.invalid.push({p: v, v: valDigit, e: translation.pattern});\n                        }\n                        v += offset;\n                    } else {\n                        if (!skipMaskChars) {\n                            buf[addMethod](maskDigit);\n                        }\n\n                        if (valDigit === maskDigit) {\n                            maskDigitPosArr.push(v);\n                            v += offset;\n                        } else {\n                            lastUntranslatedMaskChar = maskDigit;\n                            maskDigitPosArr.push(v + maskDigitCount);\n                            maskDigitCount++;\n                        }\n\n                        m += offset;\n                    }\n                }\n\n                var lastMaskCharDigit = mask.charAt(lastMaskChar);\n                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {\n                    buf.push(lastMaskCharDigit);\n                }\n\n                var newVal = buf.join('');\n                p.mapMaskdigitPositions(newVal, maskDigitPosArr, valLen);\n                return newVal;\n            },\n            mapMaskdigitPositions: function(newVal, maskDigitPosArr, valLen) {\n              var maskDiff = options.reverse ? newVal.length - valLen : 0;\n              p.maskDigitPosMap = {};\n              for (var i = 0; i < maskDigitPosArr.length; i++) {\n                p.maskDigitPosMap[maskDigitPosArr[i] + maskDiff] = 1;\n              }\n            },\n            callbacks: function (e) {\n                var val = p.val(),\n                    changed = val !== oldValue,\n                    defaultArgs = [val, e, el, options],\n                    callback = function(name, criteria, args) {\n                        if (typeof options[name] === 'function' && criteria) {\n                            options[name].apply(this, args);\n                        }\n                    };\n\n                callback('onChange', changed === true, defaultArgs);\n                callback('onKeyPress', changed === true, defaultArgs);\n                callback('onComplete', val.length === mask.length, defaultArgs);\n                callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);\n            }\n        };\n\n        el = $(el);\n        var jMask = this, oldValue = p.val(), regexMask;\n\n        mask = typeof mask === 'function' ? mask(p.val(), undefined, el,  options) : mask;\n\n        // public methods\n        jMask.mask = mask;\n        jMask.options = options;\n        jMask.remove = function() {\n            var caret = p.getCaret();\n            if (jMask.options.placeholder) {\n                el.removeAttr('placeholder');\n            }\n            if (el.data('mask-maxlength')) {\n                el.removeAttr('maxlength');\n            }\n            p.destroyEvents();\n            p.val(jMask.getCleanVal());\n            p.setCaret(caret);\n            return el;\n        };\n\n        // get value without mask\n        jMask.getCleanVal = function() {\n           return p.getMasked(true);\n        };\n\n        // get masked value without the value being in the input or element\n        jMask.getMaskedVal = function(val) {\n           return p.getMasked(false, val);\n        };\n\n       jMask.init = function(onlyMask) {\n            onlyMask = onlyMask || false;\n            options = options || {};\n\n            jMask.clearIfNotMatch  = $.jMaskGlobals.clearIfNotMatch;\n            jMask.byPassKeys       = $.jMaskGlobals.byPassKeys;\n            jMask.translation      = $.extend({}, $.jMaskGlobals.translation, options.translation);\n\n            jMask = $.extend(true, {}, jMask, options);\n\n            regexMask = p.getRegexMask();\n\n            if (onlyMask) {\n                p.events();\n                p.val(p.getMasked());\n            } else {\n                if (options.placeholder) {\n                    el.attr('placeholder' , options.placeholder);\n                }\n\n                // this is necessary, otherwise if the user submit the form\n                // and then press the \"back\" button, the autocomplete will erase\n                // the data. Works fine on IE9+, FF, Opera, Safari.\n                if (el.data('mask')) {\n                  el.attr('autocomplete', 'off');\n                }\n\n                // detect if is necessary let the user type freely.\n                // for is a lot faster than forEach.\n                for (var i = 0, maxlength = true; i < mask.length; i++) {\n                    var translation = jMask.translation[mask.charAt(i)];\n                    if (translation && translation.recursive) {\n                        maxlength = false;\n                        break;\n                    }\n                }\n\n                if (maxlength) {\n                    el.attr('maxlength', mask.length).data('mask-maxlength', true);\n                }\n\n                p.destroyEvents();\n                p.events();\n\n                var caret = p.getCaret();\n                p.val(p.getMasked());\n                p.setCaret(caret);\n            }\n        };\n\n        jMask.init(!el.is('input'));\n    };\n\n    $.maskWatchers = {};\n    var HTMLAttributes = function () {\n        var input = $(this),\n            options = {},\n            prefix = 'data-mask-',\n            mask = input.attr('data-mask');\n\n        if (input.attr(prefix + 'reverse')) {\n            options.reverse = true;\n        }\n\n        if (input.attr(prefix + 'clearifnotmatch')) {\n            options.clearIfNotMatch = true;\n        }\n\n        if (input.attr(prefix + 'selectonfocus') === 'true') {\n           options.selectOnFocus = true;\n        }\n\n        if (notSameMaskObject(input, mask, options)) {\n            return input.data('mask', new Mask(this, mask, options));\n        }\n    },\n    notSameMaskObject = function(field, mask, options) {\n        options = options || {};\n        var maskObject = $(field).data('mask'),\n            stringify = JSON.stringify,\n            value = $(field).val() || $(field).text();\n        try {\n            if (typeof mask === 'function') {\n                mask = mask(value);\n            }\n            return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;\n        } catch (e) {}\n    },\n    eventSupported = function(eventName) {\n        var el = document.createElement('div'), isSupported;\n\n        eventName = 'on' + eventName;\n        isSupported = (eventName in el);\n\n        if ( !isSupported ) {\n            el.setAttribute(eventName, 'return;');\n            isSupported = typeof el[eventName] === 'function';\n        }\n        el = null;\n\n        return isSupported;\n    };\n\n    $.fn.mask = function(mask, options) {\n        options = options || {};\n        var selector = this.selector,\n            globals = $.jMaskGlobals,\n            interval = globals.watchInterval,\n            watchInputs = options.watchInputs || globals.watchInputs,\n            maskFunction = function() {\n                if (notSameMaskObject(this, mask, options)) {\n                    return $(this).data('mask', new Mask(this, mask, options));\n                }\n            };\n\n        $(this).each(maskFunction);\n\n        if (selector && selector !== '' && watchInputs) {\n            clearInterval($.maskWatchers[selector]);\n            $.maskWatchers[selector] = setInterval(function(){\n                $(document).find(selector).each(maskFunction);\n            }, interval);\n        }\n        return this;\n    };\n\n    $.fn.masked = function(val) {\n        return this.data('mask').getMaskedVal(val);\n    };\n\n    $.fn.unmask = function() {\n        clearInterval($.maskWatchers[this.selector]);\n        delete $.maskWatchers[this.selector];\n        return this.each(function() {\n            var dataMask = $(this).data('mask');\n            if (dataMask) {\n                dataMask.remove().removeData('mask');\n            }\n        });\n    };\n\n    $.fn.cleanVal = function() {\n        return this.data('mask').getCleanVal();\n    };\n\n    $.applyDataMask = function(selector) {\n        selector = selector || $.jMaskGlobals.maskElements;\n        var $selector = (selector instanceof $) ? selector : $(selector);\n        $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);\n    };\n\n    var globals = {\n        maskElements: 'input,td,span,div',\n        dataMaskAttr: '*[data-mask]',\n        dataMask: true,\n        watchInterval: 300,\n        watchInputs: true,\n        keyStrokeCompensation: 10,\n        // old versions of chrome dont work great with input event\n        useInput: !/Chrome\\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),\n        watchDataMask: false,\n        byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],\n        translation: {\n            '0': {pattern: /\\d/},\n            '9': {pattern: /\\d/, optional: true},\n            '#': {pattern: /\\d/, recursive: true},\n            'A': {pattern: /[a-zA-Z0-9]/},\n            'S': {pattern: /[a-zA-Z]/}\n        }\n    };\n\n    $.jMaskGlobals = $.jMaskGlobals || {};\n    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);\n\n    // looking for inputs with data-mask attribute\n    if (globals.dataMask) {\n        $.applyDataMask();\n    }\n\n    setInterval(function() {\n        if ($.jMaskGlobals.watchDataMask) {\n            $.applyDataMask();\n        }\n    }, globals.watchInterval);\n}, window.jQuery, window.Zepto));\n"],"sourceRoot":"assets/scripts/"}